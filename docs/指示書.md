# 指示書：感情ベクトル(mean pooling) → cosine類似度推薦 → Streamlit UI（Docker）

## ゴール（最小構成MVP）
入力データ `data/split_song_lyrics_with_BERT2_emotions_en_100k.csv` から

1. 曲単位の感情ベクトル（GoEmotions 28次元、mean pooling）を作る
2. その曲ベクトルで cosine 類似度を計算し、Top-K の類似曲を推薦する
3. Streamlit を Docker で立ち上げ、ブラウザで以下を操作できるようにする
   - クエリ曲を選ぶ（検索 or ドロップダウン）
   - Top-K 類似曲の表を表示
   - “Connected Papers 風”として、クエリ曲中心の近傍グラフを表示（Pyvis）

※Connected Papers の厳密再現は不要。UI要件は「近い曲をグラフ状に見せ、探索できる」こと。

---

## 前提（入力CSVの構造）
`split_song_lyrics_with_BERT2_emotions_en_100k.csv` は「歌詞の1行（lyric_line）単位」で、
GoEmotionsの各感情確率列（28列）が存在する。

曲単位集約キー候補：
- 最優先：`id`（あれば）
- 次点：`title` + `artist`（両方あれば）
- さらに次点：`title` + `artist` + `year`

実装は **自動判定**で良い：
- `id` があれば `song_key = id`
- ない場合 `song_key = title + "___" + artist` で作る（欠損は空文字にして落ちないように）

---

## リポジトリ構成（作成する）
project/
data/
split_song_lyrics_with_BERT2_emotions_en_100k.csv
app/
streamlit_app.py
build_vectors.py
recommend.py
graph.py
artifacts/
song_vectors.parquet # 曲単位ベクトル（キャッシュ）
similarity_topk.parquet # TopK近傍（キャッシュ）
Dockerfile
docker-compose.yml
requirements.txt
README.md


---

## 実装方針（アルゴリズム）

### Step2：mean pooling による曲感情ベクトル
- 行ごとの感情確率ベクトル p_{i}（28次元）がある
- 曲 s の感情ベクトル E(s) を行平均で定義：
  E(s) = mean_i p_i

実装は pandas groupby で各感情列の平均を取るだけ。

感情列（28列）は次の固定リストで扱う（CSVに存在するかチェックし、欠けていたらエラー）：
- admiration, amusement, anger, annoyance, approval, caring,
  confusion, curiosity, desire, disappointment, disapproval, disgust,
  embarrassment, excitement, fear, gratitude, grief, joy, love,
  nervousness, optimism, pride, realization, relief, remorse, sadness,
  surprise, neutral

### Step5：cosine類似度で推薦
- 曲ベクトル行列 X（曲数×28）を作る
- L2正規化して cosine を計算（または sklearn の cosine_similarity を使用）
- クエリ曲 q に対し、類似度が高い順に Top-K を返す（自分自身は除外）

計算量：
- 曲数が大きいと全行列 cosine は重いので、MVPは以下の順で実装：
  1) まずは全曲同士の cosine を計算して Top-K をキャッシュ（曲数が小さければOK）
  2) 曲数が大きければ、クエリ時に 1対N の類似度計算で Top-K を返す（簡単）
     - さらに余裕があれば FAISS 等のANNは将来課題

---

## “Connected Papers 風” UI の要件（簡略版）
Connected Papers は論文同士の類似性に基づくグラフ探索ツールで、
類似したものが近く配置される force-directed graph などで表示される（本家の要素）。  
ここでは「近傍をグラフで見せる」ことを最重要とする。

### MVPのグラフ表示
- 中心ノード：クエリ曲
- 1-hop：Top-K類似曲
- （任意）2-hop：Top-Kのうち選択した曲の近傍を追加で展開（expand）

グラフ描画は Pyvis を使う（Streamlitに埋め込む既存手法がある）。
- `pyvis` + `stvis` を使用して Streamlit で表示する

---

## Docker / Streamlit 環境構築

### requirements.txt（例）
- streamlit
- pandas
- numpy
- scikit-learn
- pyarrow
- pyvis
- networkx
- stvis

### Dockerfile
- python:3.11-slim ベース
- requirements をインストール
- `streamlit run app/streamlit_app.py --server.port=8501 --server.address=0.0.0.0`

### docker-compose.yml
- ポート `8501:8501`
- ボリュームマウントで `./data` と `./artifacts` をコンテナ内に見せる
- 開発しやすいよう `./app` もマウント

---

## 実装詳細（ファイルごとの役割）

### app/build_vectors.py
責務：入力CSV → 曲ベクトル（mean pooling）を作って `artifacts/song_vectors.parquet` に保存

要件：
- 入力：`data/split_song_lyrics_with_BERT2_emotions_en_100k.csv`
- 出力：`artifacts/song_vectors.parquet`
- 出力列：
  - song_key, title, artist, year（存在するなら）
  - 28感情列（float）
  - n_lines（曲内の行数）

処理：
1. CSVを読み込み
2. `song_key` を作る（id優先）
3. groupby(song_key) で 28感情列の mean を計算
4. 代表メタ情報は最頻 or 最初の値（title/artist/year等）
5. 保存

注意：
- 感情列に欠損があれば0埋め
- ただし列自体がない場合はエラーで止める

### app/recommend.py
責務：曲ベクトル → 推薦結果（Top-K）を返す

要件：
- 入力：song_vectors（DataFrame）
- 関数：
  - `get_topk_similar(song_key: str, k: int) -> DataFrame`
- cosine 類似度の算出
- 自分自身を除外
- 返り値：similarity, song_key, title, artist, year 等を含む

キャッシュ案：
- `artifacts/similarity_topk.parquet` を作る（曲数が十分小さい時）
- 曲数が大きい場合は作らない（1対N計算）

### app/graph.py
責務：推薦結果を networkx / pyvis のグラフに変換して返す
- 中心ノードと近傍ノードを追加
- エッジは「中心→近傍」（重み=similarity）
- 2-hop展開用に `expand` 機能を用意（任意）

### app/streamlit_app.py
責務：UI
- 起動時に `song_vectors.parquet` がなければ `build_vectors.py` を実行（またはボタン）
- サイドバー：
  - 曲検索（title/artist 文字列フィルタ）
  - song_key選択
  - Top-K指定
  - （任意）2-hop展開のON/OFF
- メイン：
  - 選んだ曲のメタ情報表示
  - Top-K推薦のテーブル表示
  - Pyvisグラフ表示（Connected Papers風）

UI要件（最低限）：
- 動作が分かる
- 推薦結果（表）とグラフが一致する
- グラフのノードは hover で title/artist を見れると良い

---

## README.md に書くこと（ユーザー向け操作手順）
1) データ配置
- `data/split_song_lyrics_with_BERT2_emotions_en_100k.csv` を置く

2) 起動
- `docker compose up --build`

3) アクセス
- ブラウザで `http://localhost:8501`

4) 操作
- 曲を選択
- Top-Kを指定
- 表とグラフで類似曲を確認
- （あれば）Expandボタンで近傍追加

---

## 実装の落とし穴（必ず対策）
- `top_emotion` 列はラベル名崩れの可能性があるので **使わない**
- 推薦計算は 28感情列（確率）を使う
- ベクトルは L2正規化して cosine を計算
- 曲数が多い場合、全行列計算は避け、クエリ時に 1対N で算出する

---

## 追加（できればやる：品質向上）
- 重み付きmean pooling：Chorusを重くする（`section` 列がある場合）
- “探索”らしさ：
  - 2-hop展開
  - 類似度しきい値でエッジを間引く
  - ノードサイズを confidence（または similarity）に比例

---

## 受け入れ条件（Doneの定義）
- `docker compose up --build` で起動できる
- ブラウザで Streamlit が開き、曲が選べる
- 選択した曲に対して Top-K が表で出る
- 同じ Top-K がグラフにもノードとして出る
- 類似度（cosine）が表示される

---

## 実装メモ（参考）
- Streamlit を Docker で動かす公式ガイドに沿って作る
- Streamlit + Pyvis の埋め込みは stvis の `pv_static` を使う（既存例がある）
- cosine は sklearn の `cosine_similarity` を使う（最短で安定）
